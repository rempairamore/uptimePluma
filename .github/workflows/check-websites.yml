name: Website Availability Check with Bash

on:
  schedule:
    - cron: '*/15 * * * *'  # Run every 15 minutes
  workflow_dispatch:  # Allow manual execution

jobs:
  check-websites:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
      
      - name: Check websites availability
        env:
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_GROUP: ${{ secrets.TELEGRAM_GROUP }}
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          #!/bin/bash
          
          [[ ! -f "websites.json" ]] && { echo "websites.json missing"; exit 1; }
          jq empty websites.json || { echo "broken json"; exit 1; }
          
          retries=$(jq -r '.settings.retries' websites.json)
          timeout=$(jq -r '.settings.timeout' websites.json)
          
          tg_on=$(jq -r '.notifications.telegram.enabled' websites.json)
          slack_on=$(jq -r '.notifications.slack.enabled' websites.json)
          discord_on=$(jq -r '.notifications.discord.enabled' websites.json)
          
          # send telegram msg
          tg_send() {
            [[ "$tg_on" != "true" || -z "$TELEGRAM_TOKEN" || -z "$TELEGRAM_GROUP" ]] && return
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage" \
              -d "chat_id=${TELEGRAM_GROUP}" -d "text=$1" -d "parse_mode=HTML" &>/dev/null
          }
          
          # slack webhook
          slack_send() {
            [[ "$slack_on" != "true" || -z "$SLACK_WEBHOOK" ]] && return
            curl -s -X POST "$SLACK_WEBHOOK" -H "Content-Type: application/json" \
              -d "{\"text\":\"$1\"}" &>/dev/null
          }
          
          # discord ping
          discord_send() {
            [[ "$discord_on" != "true" || -z "$DISCORD_WEBHOOK" ]] && return
            curl -s -X POST "$DISCORD_WEBHOOK" -H "Content-Type: application/json" \
              -d "{\"content\":\"$1\"}" &>/dev/null
          }
          
          # figure out what kind of error this is
          error_type() {
            local code=$1
            (( code >= 500 )) && echo "SERVER ERROR" && return
            (( code >= 400 )) && echo "CLIENT ERROR" && return  
            (( code >= 300 )) && echo "REDIRECT" && return
            echo "UNKNOWN ERROR"
          }
          
          # main check function
          check_site() {
            local name="$1" url="$2"
            echo "Checking $name..."
            
            local site_up=false status_code="" error_type="" error_msg=""
            
            for attempt in $(seq 1 $retries); do
              [[ $attempt -gt 1 ]] && { echo "Retry $attempt/$retries"; sleep 5; }
              
              response=$(curl -s -w "%{http_code}" -H "User-Agent: Mozilla/5.0" \
                --max-time "$timeout" -L "$url" 2>&1)
              curl_code=$?
              
              if [[ $curl_code -eq 0 ]]; then
                status_code="${response: -3}"
                echo "Got status $status_code"
                [[ "$status_code" == "200" ]] && { site_up=true; break; }
                error_type=$(error_type "$status_code")
              else
                # handle curl errors
                case $curl_code in
                  28) error_type="TIMEOUT"; error_msg="timed out after ${timeout}s" ;;
                  7)  error_type="CONNECTION REFUSED"; error_msg="can't connect to host" ;;
                  *)  error_type="CONNECTION ERROR"; error_msg="curl error $curl_code" ;;
                esac
                echo "Request failed: $error_type"
              fi
            done
            
            if [[ "$site_up" == "true" ]]; then
              echo "$name is accessible"
              return 0
            fi
            
            echo "$name failed after $retries attempts"
            
            # send notifications
            if [[ -n "$status_code" ]]; then
              tg_msg="⚠️ WARNING: <b>$name</b> returned $error_type: <b>$status_code</b>%0A%0AURL: $url"
              slack_msg="⚠️ *WARNING:* *$name* returned $error_type: *$status_code*\nURL: $url" 
              discord_msg="⚠️ @here **WARNING:** **$name** returned $error_type: **$status_code**\nURL: $url"
            else
              tg_msg="⚠️ WARNING: <b>$name</b> not accessible. $error_type%0A%0AURL: $url%0AError: $error_msg"
              slack_msg="⚠️ *WARNING:* *$name* not accessible. $error_type\nURL: $url\nError: $error_msg"
              discord_msg="⚠️ @here **WARNING:** **$name** not accessible. $error_type\nURL: $url\nError: $error_msg"
            fi
            
            tg_send "$tg_msg"
            slack_send "$slack_msg" 
            discord_send "$discord_msg"
            return 1
          }
          
          # run checks on all sites
          success_count=0
          failure_count=0
          total_sites=$(jq '.websites | length' websites.json)
          
          for ((i=0; i<total_sites; i++)); do
            site_name=$(jq -r ".websites[$i].name" websites.json)
            site_url=$(jq -r ".websites[$i].URL" websites.json)
            
            if check_site "$site_name" "$site_url"; then
              ((success_count++))
            else  
              ((failure_count++))
            fi
          done
          
          echo "Check completed. $success_count sites up, $failure_count sites down"